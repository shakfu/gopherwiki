// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const clearExpiredCache = `-- name: ClearExpiredCache :exec
DELETE FROM cache WHERE datetime < ?
`

func (q *Queries) ClearExpiredCache(ctx context.Context, datetime sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, clearExpiredCache, datetime)
	return err
}

const countAdmins = `-- name: CountAdmins :one
SELECT COUNT(*) FROM user WHERE is_admin = TRUE
`

func (q *Queries) CountAdmins(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdmins)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countIssueComments = `-- name: CountIssueComments :one
SELECT COUNT(*) FROM issue_comments WHERE issue_id = ?
`

func (q *Queries) CountIssueComments(ctx context.Context, issueID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countIssueComments, issueID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countIssuesByStatus = `-- name: CountIssuesByStatus :one
SELECT COUNT(*) FROM issues WHERE status = ?
`

func (q *Queries) CountIssuesByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countIssuesByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM user
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDraft = `-- name: CreateDraft :one
INSERT INTO drafts (
    pagepath, revision, author_email, content, cursor_line, cursor_ch, datetime
) VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, pagepath, revision, author_email, content, cursor_line, cursor_ch, datetime
`

type CreateDraftParams struct {
	Pagepath    sql.NullString `json:"pagepath"`
	Revision    sql.NullString `json:"revision"`
	AuthorEmail sql.NullString `json:"author_email"`
	Content     sql.NullString `json:"content"`
	CursorLine  sql.NullInt64  `json:"cursor_line"`
	CursorCh    sql.NullInt64  `json:"cursor_ch"`
	Datetime    sql.NullTime   `json:"datetime"`
}

func (q *Queries) CreateDraft(ctx context.Context, arg CreateDraftParams) (Draft, error) {
	row := q.db.QueryRowContext(ctx, createDraft,
		arg.Pagepath,
		arg.Revision,
		arg.AuthorEmail,
		arg.Content,
		arg.CursorLine,
		arg.CursorCh,
		arg.Datetime,
	)
	var i Draft
	err := row.Scan(
		&i.ID,
		&i.Pagepath,
		&i.Revision,
		&i.AuthorEmail,
		&i.Content,
		&i.CursorLine,
		&i.CursorCh,
		&i.Datetime,
	)
	return i, err
}

const createIssue = `-- name: CreateIssue :one
INSERT INTO issues (title, description, status, category, tags, created_by_name, created_by_email, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, title, description, status, category, tags, created_by_name, created_by_email, created_at, updated_at
`

type CreateIssueParams struct {
	Title          string         `json:"title"`
	Description    sql.NullString `json:"description"`
	Status         string         `json:"status"`
	Category       sql.NullString `json:"category"`
	Tags           sql.NullString `json:"tags"`
	CreatedByName  sql.NullString `json:"created_by_name"`
	CreatedByEmail sql.NullString `json:"created_by_email"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
}

func (q *Queries) CreateIssue(ctx context.Context, arg CreateIssueParams) (Issue, error) {
	row := q.db.QueryRowContext(ctx, createIssue,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.Category,
		arg.Tags,
		arg.CreatedByName,
		arg.CreatedByEmail,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Category,
		&i.Tags,
		&i.CreatedByName,
		&i.CreatedByEmail,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createIssueComment = `-- name: CreateIssueComment :one

INSERT INTO issue_comments (issue_id, content, author_name, author_email, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?) RETURNING id, issue_id, content, author_name, author_email, created_at, updated_at
`

type CreateIssueCommentParams struct {
	IssueID     int64          `json:"issue_id"`
	Content     string         `json:"content"`
	AuthorName  sql.NullString `json:"author_name"`
	AuthorEmail sql.NullString `json:"author_email"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
}

// Issue Comment queries
func (q *Queries) CreateIssueComment(ctx context.Context, arg CreateIssueCommentParams) (IssueComment, error) {
	row := q.db.QueryRowContext(ctx, createIssueComment,
		arg.IssueID,
		arg.Content,
		arg.AuthorName,
		arg.AuthorEmail,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i IssueComment
	err := row.Scan(
		&i.ID,
		&i.IssueID,
		&i.Content,
		&i.AuthorName,
		&i.AuthorEmail,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO user (
    name, email, password_hash, first_seen, last_seen,
    is_approved, is_admin, email_confirmed, allow_read, allow_write, allow_upload
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, email, password_hash, first_seen, last_seen, is_approved, is_admin, email_confirmed, allow_read, allow_write, allow_upload
`

type CreateUserParams struct {
	Name           string         `json:"name"`
	Email          string         `json:"email"`
	PasswordHash   sql.NullString `json:"password_hash"`
	FirstSeen      sql.NullTime   `json:"first_seen"`
	LastSeen       sql.NullTime   `json:"last_seen"`
	IsApproved     sql.NullBool   `json:"is_approved"`
	IsAdmin        sql.NullBool   `json:"is_admin"`
	EmailConfirmed sql.NullBool   `json:"email_confirmed"`
	AllowRead      sql.NullBool   `json:"allow_read"`
	AllowWrite     sql.NullBool   `json:"allow_write"`
	AllowUpload    sql.NullBool   `json:"allow_upload"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.FirstSeen,
		arg.LastSeen,
		arg.IsApproved,
		arg.IsAdmin,
		arg.EmailConfirmed,
		arg.AllowRead,
		arg.AllowWrite,
		arg.AllowUpload,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.FirstSeen,
		&i.LastSeen,
		&i.IsApproved,
		&i.IsAdmin,
		&i.EmailConfirmed,
		&i.AllowRead,
		&i.AllowWrite,
		&i.AllowUpload,
	)
	return i, err
}

const deleteCache = `-- name: DeleteCache :exec
DELETE FROM cache WHERE key = ?
`

func (q *Queries) DeleteCache(ctx context.Context, key string) error {
	_, err := q.db.ExecContext(ctx, deleteCache, key)
	return err
}

const deleteDraft = `-- name: DeleteDraft :exec
DELETE FROM drafts WHERE pagepath = ? AND author_email = ?
`

type DeleteDraftParams struct {
	Pagepath    sql.NullString `json:"pagepath"`
	AuthorEmail sql.NullString `json:"author_email"`
}

func (q *Queries) DeleteDraft(ctx context.Context, arg DeleteDraftParams) error {
	_, err := q.db.ExecContext(ctx, deleteDraft, arg.Pagepath, arg.AuthorEmail)
	return err
}

const deleteDraftByID = `-- name: DeleteDraftByID :exec
DELETE FROM drafts WHERE id = ?
`

func (q *Queries) DeleteDraftByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDraftByID, id)
	return err
}

const deleteExpiredAnonymousDrafts = `-- name: DeleteExpiredAnonymousDrafts :exec
DELETE FROM drafts WHERE author_email LIKE 'anonymous_uid:%' AND datetime < ?
`

func (q *Queries) DeleteExpiredAnonymousDrafts(ctx context.Context, datetime sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredAnonymousDrafts, datetime)
	return err
}

const deleteIssue = `-- name: DeleteIssue :exec
DELETE FROM issues WHERE id = ?
`

func (q *Queries) DeleteIssue(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteIssue, id)
	return err
}

const deleteIssueComment = `-- name: DeleteIssueComment :exec
DELETE FROM issue_comments WHERE id = ?
`

func (q *Queries) DeleteIssueComment(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteIssueComment, id)
	return err
}

const deleteIssueComments = `-- name: DeleteIssueComments :exec
DELETE FROM issue_comments WHERE issue_id = ?
`

func (q *Queries) DeleteIssueComments(ctx context.Context, issueID int64) error {
	_, err := q.db.ExecContext(ctx, deleteIssueComments, issueID)
	return err
}

const deletePreference = `-- name: DeletePreference :exec
DELETE FROM preferences WHERE name = ?
`

func (q *Queries) DeletePreference(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deletePreference, name)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM user WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getCache = `-- name: GetCache :one

SELECT key, value, datetime FROM cache WHERE key = ? LIMIT 1
`

// Cache queries
func (q *Queries) GetCache(ctx context.Context, key string) (Cache, error) {
	row := q.db.QueryRowContext(ctx, getCache, key)
	var i Cache
	err := row.Scan(&i.Key, &i.Value, &i.Datetime)
	return i, err
}

const getDraft = `-- name: GetDraft :one

SELECT id, pagepath, revision, author_email, content, cursor_line, cursor_ch, datetime FROM drafts WHERE pagepath = ? AND author_email = ? LIMIT 1
`

type GetDraftParams struct {
	Pagepath    sql.NullString `json:"pagepath"`
	AuthorEmail sql.NullString `json:"author_email"`
}

// Drafts queries
func (q *Queries) GetDraft(ctx context.Context, arg GetDraftParams) (Draft, error) {
	row := q.db.QueryRowContext(ctx, getDraft, arg.Pagepath, arg.AuthorEmail)
	var i Draft
	err := row.Scan(
		&i.ID,
		&i.Pagepath,
		&i.Revision,
		&i.AuthorEmail,
		&i.Content,
		&i.CursorLine,
		&i.CursorCh,
		&i.Datetime,
	)
	return i, err
}

const getDraftByID = `-- name: GetDraftByID :one
SELECT id, pagepath, revision, author_email, content, cursor_line, cursor_ch, datetime FROM drafts WHERE id = ? LIMIT 1
`

func (q *Queries) GetDraftByID(ctx context.Context, id int64) (Draft, error) {
	row := q.db.QueryRowContext(ctx, getDraftByID, id)
	var i Draft
	err := row.Scan(
		&i.ID,
		&i.Pagepath,
		&i.Revision,
		&i.AuthorEmail,
		&i.Content,
		&i.CursorLine,
		&i.CursorCh,
		&i.Datetime,
	)
	return i, err
}

const getIssue = `-- name: GetIssue :one

SELECT id, title, description, status, category, tags, created_by_name, created_by_email, created_at, updated_at FROM issues WHERE id = ?
`

// Issue queries
func (q *Queries) GetIssue(ctx context.Context, id int64) (Issue, error) {
	row := q.db.QueryRowContext(ctx, getIssue, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Category,
		&i.Tags,
		&i.CreatedByName,
		&i.CreatedByEmail,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIssueComment = `-- name: GetIssueComment :one
SELECT id, issue_id, content, author_name, author_email, created_at, updated_at FROM issue_comments WHERE id = ?
`

func (q *Queries) GetIssueComment(ctx context.Context, id int64) (IssueComment, error) {
	row := q.db.QueryRowContext(ctx, getIssueComment, id)
	var i IssueComment
	err := row.Scan(
		&i.ID,
		&i.IssueID,
		&i.Content,
		&i.AuthorName,
		&i.AuthorEmail,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPreference = `-- name: GetPreference :one
SELECT name, value FROM preferences WHERE name = ? LIMIT 1
`

func (q *Queries) GetPreference(ctx context.Context, name string) (Preference, error) {
	row := q.db.QueryRowContext(ctx, getPreference, name)
	var i Preference
	err := row.Scan(&i.Name, &i.Value)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password_hash, first_seen, last_seen, is_approved, is_admin, email_confirmed, allow_read, allow_write, allow_upload FROM user WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.FirstSeen,
		&i.LastSeen,
		&i.IsApproved,
		&i.IsAdmin,
		&i.EmailConfirmed,
		&i.AllowRead,
		&i.AllowWrite,
		&i.AllowUpload,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT id, name, email, password_hash, first_seen, last_seen, is_approved, is_admin, email_confirmed, allow_read, allow_write, allow_upload FROM user WHERE id = ? LIMIT 1
`

// User queries
func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.FirstSeen,
		&i.LastSeen,
		&i.IsApproved,
		&i.IsAdmin,
		&i.EmailConfirmed,
		&i.AllowRead,
		&i.AllowWrite,
		&i.AllowUpload,
	)
	return i, err
}

const listDistinctCategories = `-- name: ListDistinctCategories :many
SELECT DISTINCT category FROM issues WHERE category IS NOT NULL AND category != '' ORDER BY category
`

func (q *Queries) ListDistinctCategories(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, listDistinctCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []sql.NullString{}
	for rows.Next() {
		var category sql.NullString
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDraftsByPagepath = `-- name: ListDraftsByPagepath :many
SELECT id, pagepath, revision, author_email, content, cursor_line, cursor_ch, datetime FROM drafts WHERE pagepath = ? ORDER BY datetime DESC
`

func (q *Queries) ListDraftsByPagepath(ctx context.Context, pagepath sql.NullString) ([]Draft, error) {
	rows, err := q.db.QueryContext(ctx, listDraftsByPagepath, pagepath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Draft{}
	for rows.Next() {
		var i Draft
		if err := rows.Scan(
			&i.ID,
			&i.Pagepath,
			&i.Revision,
			&i.AuthorEmail,
			&i.Content,
			&i.CursorLine,
			&i.CursorCh,
			&i.Datetime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIssueComments = `-- name: ListIssueComments :many
SELECT id, issue_id, content, author_name, author_email, created_at, updated_at FROM issue_comments WHERE issue_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListIssueComments(ctx context.Context, issueID int64) ([]IssueComment, error) {
	rows, err := q.db.QueryContext(ctx, listIssueComments, issueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IssueComment{}
	for rows.Next() {
		var i IssueComment
		if err := rows.Scan(
			&i.ID,
			&i.IssueID,
			&i.Content,
			&i.AuthorName,
			&i.AuthorEmail,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIssues = `-- name: ListIssues :many
SELECT id, title, description, status, category, tags, created_by_name, created_by_email, created_at, updated_at FROM issues ORDER BY category, created_at DESC
`

func (q *Queries) ListIssues(ctx context.Context) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listIssues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Category,
			&i.Tags,
			&i.CreatedByName,
			&i.CreatedByEmail,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIssuesByCategory = `-- name: ListIssuesByCategory :many
SELECT id, title, description, status, category, tags, created_by_name, created_by_email, created_at, updated_at FROM issues WHERE category = ? ORDER BY created_at DESC
`

func (q *Queries) ListIssuesByCategory(ctx context.Context, category sql.NullString) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listIssuesByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Category,
			&i.Tags,
			&i.CreatedByName,
			&i.CreatedByEmail,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIssuesByCategoryAndStatus = `-- name: ListIssuesByCategoryAndStatus :many
SELECT id, title, description, status, category, tags, created_by_name, created_by_email, created_at, updated_at FROM issues WHERE category = ? AND status = ? ORDER BY created_at DESC
`

type ListIssuesByCategoryAndStatusParams struct {
	Category sql.NullString `json:"category"`
	Status   string         `json:"status"`
}

func (q *Queries) ListIssuesByCategoryAndStatus(ctx context.Context, arg ListIssuesByCategoryAndStatusParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listIssuesByCategoryAndStatus, arg.Category, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Category,
			&i.Tags,
			&i.CreatedByName,
			&i.CreatedByEmail,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIssuesByStatus = `-- name: ListIssuesByStatus :many
SELECT id, title, description, status, category, tags, created_by_name, created_by_email, created_at, updated_at FROM issues WHERE status = ? ORDER BY category, created_at DESC
`

func (q *Queries) ListIssuesByStatus(ctx context.Context, status string) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listIssuesByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Category,
			&i.Tags,
			&i.CreatedByName,
			&i.CreatedByEmail,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPreferences = `-- name: ListPreferences :many
SELECT name, value FROM preferences ORDER BY name
`

func (q *Queries) ListPreferences(ctx context.Context) ([]Preference, error) {
	rows, err := q.db.QueryContext(ctx, listPreferences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Preference{}
	for rows.Next() {
		var i Preference
		if err := rows.Scan(&i.Name, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, email, password_hash, first_seen, last_seen, is_approved, is_admin, email_confirmed, allow_read, allow_write, allow_upload FROM user ORDER BY name
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.PasswordHash,
			&i.FirstSeen,
			&i.LastSeen,
			&i.IsApproved,
			&i.IsAdmin,
			&i.EmailConfirmed,
			&i.AllowRead,
			&i.AllowWrite,
			&i.AllowUpload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCache = `-- name: SetCache :exec
INSERT INTO cache (key, value, datetime) VALUES (?, ?, ?)
ON CONFLICT(key) DO UPDATE SET value = excluded.value, datetime = excluded.datetime
`

type SetCacheParams struct {
	Key      string         `json:"key"`
	Value    sql.NullString `json:"value"`
	Datetime sql.NullTime   `json:"datetime"`
}

func (q *Queries) SetCache(ctx context.Context, arg SetCacheParams) error {
	_, err := q.db.ExecContext(ctx, setCache, arg.Key, arg.Value, arg.Datetime)
	return err
}

const updateDraft = `-- name: UpdateDraft :exec
UPDATE drafts SET
    revision = ?,
    content = ?,
    cursor_line = ?,
    cursor_ch = ?,
    datetime = ?
WHERE id = ?
`

type UpdateDraftParams struct {
	Revision   sql.NullString `json:"revision"`
	Content    sql.NullString `json:"content"`
	CursorLine sql.NullInt64  `json:"cursor_line"`
	CursorCh   sql.NullInt64  `json:"cursor_ch"`
	Datetime   sql.NullTime   `json:"datetime"`
	ID         int64          `json:"id"`
}

func (q *Queries) UpdateDraft(ctx context.Context, arg UpdateDraftParams) error {
	_, err := q.db.ExecContext(ctx, updateDraft,
		arg.Revision,
		arg.Content,
		arg.CursorLine,
		arg.CursorCh,
		arg.Datetime,
		arg.ID,
	)
	return err
}

const updateIssue = `-- name: UpdateIssue :exec
UPDATE issues SET title = ?, description = ?, status = ?, category = ?, tags = ?, updated_at = ? WHERE id = ?
`

type UpdateIssueParams struct {
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Status      string         `json:"status"`
	Category    sql.NullString `json:"category"`
	Tags        sql.NullString `json:"tags"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateIssue(ctx context.Context, arg UpdateIssueParams) error {
	_, err := q.db.ExecContext(ctx, updateIssue,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.Category,
		arg.Tags,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE user SET
    name = ?,
    email = ?,
    password_hash = ?,
    last_seen = ?,
    is_approved = ?,
    is_admin = ?,
    email_confirmed = ?,
    allow_read = ?,
    allow_write = ?,
    allow_upload = ?
WHERE id = ?
`

type UpdateUserParams struct {
	Name           string         `json:"name"`
	Email          string         `json:"email"`
	PasswordHash   sql.NullString `json:"password_hash"`
	LastSeen       sql.NullTime   `json:"last_seen"`
	IsApproved     sql.NullBool   `json:"is_approved"`
	IsAdmin        sql.NullBool   `json:"is_admin"`
	EmailConfirmed sql.NullBool   `json:"email_confirmed"`
	AllowRead      sql.NullBool   `json:"allow_read"`
	AllowWrite     sql.NullBool   `json:"allow_write"`
	AllowUpload    sql.NullBool   `json:"allow_upload"`
	ID             int64          `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.LastSeen,
		arg.IsApproved,
		arg.IsAdmin,
		arg.EmailConfirmed,
		arg.AllowRead,
		arg.AllowWrite,
		arg.AllowUpload,
		arg.ID,
	)
	return err
}

const updateUserLastSeen = `-- name: UpdateUserLastSeen :exec
UPDATE user SET last_seen = ? WHERE id = ?
`

type UpdateUserLastSeenParams struct {
	LastSeen sql.NullTime `json:"last_seen"`
	ID       int64        `json:"id"`
}

func (q *Queries) UpdateUserLastSeen(ctx context.Context, arg UpdateUserLastSeenParams) error {
	_, err := q.db.ExecContext(ctx, updateUserLastSeen, arg.LastSeen, arg.ID)
	return err
}

const upsertDraft = `-- name: UpsertDraft :exec
INSERT INTO drafts (pagepath, revision, author_email, content, cursor_line, cursor_ch, datetime)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT DO UPDATE SET
    revision = excluded.revision,
    content = excluded.content,
    cursor_line = excluded.cursor_line,
    cursor_ch = excluded.cursor_ch,
    datetime = excluded.datetime
WHERE pagepath = excluded.pagepath AND author_email = excluded.author_email
`

type UpsertDraftParams struct {
	Pagepath    sql.NullString `json:"pagepath"`
	Revision    sql.NullString `json:"revision"`
	AuthorEmail sql.NullString `json:"author_email"`
	Content     sql.NullString `json:"content"`
	CursorLine  sql.NullInt64  `json:"cursor_line"`
	CursorCh    sql.NullInt64  `json:"cursor_ch"`
	Datetime    sql.NullTime   `json:"datetime"`
}

func (q *Queries) UpsertDraft(ctx context.Context, arg UpsertDraftParams) error {
	_, err := q.db.ExecContext(ctx, upsertDraft,
		arg.Pagepath,
		arg.Revision,
		arg.AuthorEmail,
		arg.Content,
		arg.CursorLine,
		arg.CursorCh,
		arg.Datetime,
	)
	return err
}

const upsertPreference = `-- name: UpsertPreference :exec
INSERT INTO preferences (name, value) VALUES (?, ?)
ON CONFLICT(name) DO UPDATE SET value = excluded.value
`

type UpsertPreferenceParams struct {
	Name  string         `json:"name"`
	Value sql.NullString `json:"value"`
}

func (q *Queries) UpsertPreference(ctx context.Context, arg UpsertPreferenceParams) error {
	_, err := q.db.ExecContext(ctx, upsertPreference, arg.Name, arg.Value)
	return err
}
